:::snippet XML 文档穿件

创建 xml 文档：`document.implementation.createDocument(namespaceUri, root, doctype)`

```javascript
var xmldom = document.implementation.createDocument("", "root", null);
alert(xmldom.documentElement.tagName); //root
var child = xmldom.createElement("child");
xmldom.documentElement.appendChild(child);
```

:::

:::snippet DOMParser 类型

1. 将 xml 解析为 dom 文档

```javascript
var parser = new DOMParser();
var xmldom = parser.parseFromString("<root><child/></root>", "text/xml");
alert(xmldom.documentElement.tagName); //"root"
alert(xmldom.documentElement.firstChild.tagName);
var anotherChild = xmldom.createElement("child");
xmldom.documentElement.appendChild(anotherChild);
var children = xmldom.getElementsByTagName("child");
alert(children.length); //2
```

2. IE9 兼容处理 `parseFromString()` 方法报错

```javascript
var parser = new DOMParser(),
  xmldom,
  errors;
try {
  xmldom = parser.parseFromString("<root>", "text/xml");
  errors = xmldom.getElementsByTagName("parsererror");
  if (errors.length > 0) {
    throw new Error("Parsing error!");
  }
} catch (ex) {
  alert("Parsing error!");
}
```

:::

:::snippet XMLSerializer 类型

DOM 序列化 XML

```javascript
var serializer = new XMLSerializer();
var xml = serializer.serializeToString(xmldom);
alert(xml);
```

:::

:::snippet 跨浏览器处理 XML

```javascript
function parseXml(xml) {
  var xmldom = null;
  if (typeof DOMParser != "undefined") {
    xmldom = new DOMParser().parseFromString(xml, "text/xml");
    var errors = xmldom.getElementsByTagName("parsererror");
    if (errors.length) {
      throw new Error("XML parsing error:" + errors[0].textContent);
    }
  } else if (typeof ActiveXObject != "undefined") {
    //IE8及以前版本兼容处理
    xmldom = createDocument();
    xmldom.loadXML(xml);
    if (xmldom.parseError != 0) {
      throw new Error("XML parsing error: " + xmldom.parseError.reason);
    }
  } else {
    throw new Error("No XML parser available.");
  }
  return xmldom;
}
```

:::

:::snippet XPath 处理 XML

通过 XPath 可以对 XML 文档进行查询节点处理操作

```javascript
function selectNodes(context, expression, namespaces) {
  var doc = context.nodeType != 9 ? context.ownerDocument : context;
  if (typeof doc.evaluate != "undefined") {
    var nsresolver = null;
    if (namespaces instanceof Object) {
      nsresolver = function(prefix) {
        return namespaces[prefix];
      };
    }
    var result = doc.evaluate(
      expression,
      context,
      nsresolver,
      XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
      null
    );
    var nodes = new Array();
    if (result !== null) {
      for (var i = 0, len = result.snapshotLength; i < len; i++) {
        nodes.push(result.snapshotItem(i));
      }
    }
    return nodes;
  } else if (typeof context.selectNodes != "undefined") {
    //创建命名空间字符串
    if (namespaces instanceof Object) {
      var ns = "";
      for (var prefix in namespaces) {
        if (namespaces.hasOwnProperty(prefix)) {
          ns += "xmlns:" + prefix + "='" + namespaces[prefix] + "' ";
        }
      }
      doc.setProperty("SelectionNamespaces", ns);
    }
    var result = context.selectNodes(expression);
    var nodes = new Array();
    for (var i = 0, len = result.length; i < len; i++) {
      nodes.push(result[i]);
    }
    return nodes;
  } else {
    throw new Error("No XPath engine found.");
  }
}
```

```javascript
var result = selectNodes(xmldom.documentElement, "wrox:book/wrox:author", {
  wrox: "http://www.wrox.com/"
});
CrossBrowserXPathExample02.htm;
alert(result.length);
```

:::

:::snippet E4X 的类型

1. 定义全局对象来处理 XML

| 全局对象  | 描述                                        |
| :-------- | :------------------------------------------ |
| XML       | XML 结构中的任何一个独立的部分。            |
| XMLList   | XML 对象的集合。                            |
| Namespace | 命名空间前缀与命名空间 URI 之间的映射。     |
| QName     | 由内部名称和命名空间 URI 组成的一个限定名。 |

2. XML 类型

```javascript
var x = new XML(
  '<employee position="Software Engineer"><name>Nicholas Zakas</name></employee>'
);
```

2. XMLList 类型

```javascript
var list = new XMLList("<item/><item/>");
```

> 通过 XML 和 XMLList 两种基本类型来处理所有的 XML，通过方法和对应的属性操作

:::

:::snippet JSON 基本语法

1. 简单值:使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON 不支持 JavaScript 中的特殊值 undefined。
2. 对象:对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。
3. 数组:数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。

> JSON 不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴。

:::

:::snippet JSON 对象

1. JSON 对象定义

```javascript
var book = {
  title: "Professional JavaScript",
  authors: ["Nicholas C. Zakas"],
  edition: 3,
  year: 2011
};
```

2. JSON 序列化

```javascript
var jsonText = JSON.stringify(book);
//{"title":"Professional JavaScript","authors":["Nicholas C. Zakas"],"edition":3, "year":2011}
```

3. 序列化过滤

```javascript
var book = {
  title: "Professional JavaScript",
  authors: ["Nicholas C. Zakas"],
  edition: 3,
  year: 2011
};
var jsonText = JSON.stringify(book, ["title", "edition"]);
//{"title":"Professional JavaScript","edition":3}
```

```javascript
var book = {
  title: "Professional JavaScript",
  authors: ["Nicholas C. Zakas"],
  edition: 3,
  year: 2011
};
var jsonText = JSON.stringify(book, null, function(key, value) {
  switch (key) {
    case "authors":
      return value.join(",");
    case "year":
      return 5000;
    case "edition":
      return undefined;
    default:
      return value;
  }
});
//{"title":"Professional JavaScript","authors":"Nicholas C. Zakas","year":5000}
```

4. toJSON()方法，自定义处理

```javascript
var book = {
  title: "Professional JavaScript",
  authors: ["Nicholas C. Zakas"],
  edition: 3,
  year: 2011,
  toJSON: function() {
    return this.title;
  }
};
var jsonText = JSON.stringify(book);
```

5. JSON.parse() 解析 JSON 字符串

```javascript
var book = {
  title: "Professional JavaScript",
  authors: ["Nicholas C. Zakas"],
  edition: 3,
  year: 2011,
  releaseDate: new Date(2011, 11, 1)
};
var jsonText = JSON.stringify(book);
var bookCopy = JSON.parse(jsonText, function(key, value) {
  if (key == "releaseDate") {
    return new Date(value);
  } else {
    return value;
  }
});
alert(bookCopy.releaseDate.getFullYear());
```

> IE8 以前不支持 JSON 对象方法可以使用 [json2.js](https://github.com/douglascrockford/JSON-js/blob/master/json2.js)

:::

:::snippet XMLHttpRequest 对象

1. IE8 以前 XHR 是 MSXML 库中的一个 ActiveX 对象实现的，其他浏览器可以直接使用 XMLHttpRequest

```javascript
function createXHR() {
  if (typeof XMLHttpRequest != "undefined") {
    return new XMLHttpRequest();
  } else if (typeof ActiveXObject != "undefined") {
    if (typeof arguments.callee.activeXString != "string") {
      var versions = [
          "MSXML2.XMLHttp.6.0",
          "MSXML2.XMLHttp.3.0",
          "MSXML2.XMLHttp"
        ],
        i,
        len;

      for (i = 0, len = versions.length; i < len; i++) {
        try {
          new ActiveXObject(versions[i]);
          arguments.callee.activeXString = versions[i];
          break;
        } catch (ex) {
          //跳过
        }
      }
    }
    return new ActiveXObject(arguments.callee.activeXString);
  } else {
    throw new Error("No XHR object available.");
  }
}
```

2. XHR 消息状态属性

| 属性         | 描述                                                                                               |
| :----------- | :------------------------------------------------------------------------------------------------- |
| responseText | 作为响应主体被返回的文本。                                                                         |
| responseXML  | 如果响应的内容类型是"text/xml"或"application/xml"，这个属性中将保存包含着响应数据的 XML DOM 文档。 |
| status       | 响应的 HTTP 状态。                                                                                 |
| statusText   | HTTP 状态的说明。                                                                                  |

3. 同步消息处理

```javascript
xhr.open("get", "example.txt", false);
xhr.send(null);
if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
  alert(xhr.responseText);
} else {
  alert("Request was unsuccessful: " + xhr.status);
}
```

4. 异步请求状态 readyState

| 值  | 描述                                                       |
| :-- | :--------------------------------------------------------- |
| 0   | 未初始化。尚未调用 open()方法。                            |
| 1   | 启动。已经调用 open()方法，但尚未调用 send()方法。         |
| 2   | 发送。已经调用 send()方法，但尚未接收到响应。              |
| 3   | 接收。已经接收到部分响应数据。                             |
| 4   | 完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 |

5. readyState 值改变触发 readystatechange 事件

```javascript
var xhr = createXHR();
xhr.onreadystatechange = function() {
  if (xhr.readyState == 4) {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
      alert(xhr.responseText);
    } else {
      alert("Request was unsuccessful: " + xhr.status);
    }
  }
};
xhr.open("get", "example.txt", true);
xhr.send(null);
```

6. abort()方法取消请求

```javascript
xhr.abort();
```

:::

:::snippet HTTP 头部信息

1. 属性

| 属性            | 描述                           |
| :-------------- | :----------------------------- |
| Accept          | 浏览器能够处理的内容类型。     |
| Accept-Charset  | 浏览器能够显示的字符集。       |
| Accept-Encoding | 浏览器能够处理的压缩编码。     |
| Accept-Language | 浏览器当前设置的语言。         |
| Connection      | 浏览器与服务器之间连接的类型。 |
| Cookie          | 当前页面设置的任何 Cookie。    |
| Host            | 发出请求的页面所在的域 。      |
| Referer         | 发出请求的页面的 URI。         |
| User-Agent      | 浏览器的用户代理字符串。       |

2. setRequestHeader() 设置请求头

```javascript
var xhr = createXHR();
xhr.onreadystatechange = function() {
  if (xhr.readyState == 4) {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
      alert(xhr.responseText);
    } else {
      alert("Request was unsuccessful: " + xhr.status);
    }
  }
};
xhr.open("get", "example.php", true);
xhr.setRequestHeader("MyHeader", "MyValue");
xhr.send(null);
```

> 要成功发送请求头部信息，必须在调用 open()方法之后且调用 send()方法 之前调用 setRequestHeader(),设置请求头信息有的浏览器不允许覆盖原有参数

3. getResponseHeader()和 getAllResponseHeaders()方法获取请求头参数

```javascript
var myHeader = xhr.getResponseHeader("MyHeader");
var allHeaders = xhr.getAllResponseHeaders();
```

:::
