:::snippet XML 文档穿件

创建 xml 文档：`document.implementation.createDocument(namespaceUri, root, doctype)`

```javascript
var xmldom = document.implementation.createDocument("", "root", null);
alert(xmldom.documentElement.tagName); //root
var child = xmldom.createElement("child");
xmldom.documentElement.appendChild(child);
```

:::

:::snippet DOMParser 类型

1. 将 xml 解析为 dom 文档

```javascript
var parser = new DOMParser();
var xmldom = parser.parseFromString("<root><child/></root>", "text/xml");
alert(xmldom.documentElement.tagName); //"root"
alert(xmldom.documentElement.firstChild.tagName);
var anotherChild = xmldom.createElement("child");
xmldom.documentElement.appendChild(anotherChild);
var children = xmldom.getElementsByTagName("child");
alert(children.length); //2
```

2. IE9 兼容处理 `parseFromString()` 方法报错

```javascript
var parser = new DOMParser(),
  xmldom,
  errors;
try {
  xmldom = parser.parseFromString("<root>", "text/xml");
  errors = xmldom.getElementsByTagName("parsererror");
  if (errors.length > 0) {
    throw new Error("Parsing error!");
  }
} catch (ex) {
  alert("Parsing error!");
}
```

:::

:::snippet XMLSerializer 类型

DOM 序列化 XML

```javascript
var serializer = new XMLSerializer();
var xml = serializer.serializeToString(xmldom);
alert(xml);
```

:::

:::snippet 跨浏览器处理 XML

```javascript
function parseXml(xml) {
  var xmldom = null;
  if (typeof DOMParser != "undefined") {
    xmldom = new DOMParser().parseFromString(xml, "text/xml");
    var errors = xmldom.getElementsByTagName("parsererror");
    if (errors.length) {
      throw new Error("XML parsing error:" + errors[0].textContent);
    }
  } else if (typeof ActiveXObject != "undefined") {
    //IE8及以前版本兼容处理
    xmldom = createDocument();
    xmldom.loadXML(xml);
    if (xmldom.parseError != 0) {
      throw new Error("XML parsing error: " + xmldom.parseError.reason);
    }
  } else {
    throw new Error("No XML parser available.");
  }
  return xmldom;
}
```

:::

:::snippet XPath 处理 XML

通过 XPath 可以对 XML 文档进行查询节点处理操作

```javascript
function selectNodes(context, expression, namespaces) {
  var doc = context.nodeType != 9 ? context.ownerDocument : context;
  if (typeof doc.evaluate != "undefined") {
    var nsresolver = null;
    if (namespaces instanceof Object) {
      nsresolver = function(prefix) {
        return namespaces[prefix];
      };
    }
    var result = doc.evaluate(
      expression,
      context,
      nsresolver,
      XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
      null
    );
    var nodes = new Array();
    if (result !== null) {
      for (var i = 0, len = result.snapshotLength; i < len; i++) {
        nodes.push(result.snapshotItem(i));
      }
    }
    return nodes;
  } else if (typeof context.selectNodes != "undefined") {
    //创建命名空间字符串
    if (namespaces instanceof Object) {
      var ns = "";
      for (var prefix in namespaces) {
        if (namespaces.hasOwnProperty(prefix)) {
          ns += "xmlns:" + prefix + "='" + namespaces[prefix] + "' ";
        }
      }
      doc.setProperty("SelectionNamespaces", ns);
    }
    var result = context.selectNodes(expression);
    var nodes = new Array();
    for (var i = 0, len = result.length; i < len; i++) {
      nodes.push(result[i]);
    }
    return nodes;
  } else {
    throw new Error("No XPath engine found.");
  }
}
```

```javascript
var result = selectNodes(xmldom.documentElement, "wrox:book/wrox:author", {
  wrox: "http://www.wrox.com/"
});
CrossBrowserXPathExample02.htm;
alert(result.length);
```

:::

:::snippet E4X 的类型

1. 定义全局对象来处理 XML

| 全局对象  | 描述                                        |
| :-------- | :------------------------------------------ |
| XML       | XML 结构中的任何一个独立的部分。            |
| XMLList   | XML 对象的集合。                            |
| Namespace | 命名空间前缀与命名空间 URI 之间的映射。     |
| QName     | 由内部名称和命名空间 URI 组成的一个限定名。 |

2. XML 类型

```javascript
var x = new XML(
  '<employee position="Software Engineer"><name>Nicholas Zakas</name></employee>'
);
```

2. XMLList 类型

```javascript
var list = new XMLList("<item/><item/>");
```

> 通过 XML 和 XMLList 两种基本类型来处理所有的 XML，通过方法和对应的属性操作

:::

:::snippet JSON 基本语法

1. 简单值:使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON 不支持 JavaScript 中的特殊值 undefined。
2. 对象:对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。
3. 数组:数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。

> JSON 不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴。

:::

:::snippet JSON 对象

1. JSON 对象定义

```javascript
var book = {
  title: "Professional JavaScript",
  authors: ["Nicholas C. Zakas"],
  edition: 3,
  year: 2011
};
```

2. JSON 序列化

```javascript
var jsonText = JSON.stringify(book);
//{"title":"Professional JavaScript","authors":["Nicholas C. Zakas"],"edition":3, "year":2011}
```

3. 序列化过滤

```javascript
var book = {
  title: "Professional JavaScript",
  authors: ["Nicholas C. Zakas"],
  edition: 3,
  year: 2011
};
var jsonText = JSON.stringify(book, ["title", "edition"]);
//{"title":"Professional JavaScript","edition":3}
```

```javascript
var book = {
  title: "Professional JavaScript",
  authors: ["Nicholas C. Zakas"],
  edition: 3,
  year: 2011
};
var jsonText = JSON.stringify(book, null, function(key, value) {
  switch (key) {
    case "authors":
      return value.join(",");
    case "year":
      return 5000;
    case "edition":
      return undefined;
    default:
      return value;
  }
});
//{"title":"Professional JavaScript","authors":"Nicholas C. Zakas","year":5000}
```

4. toJSON()方法，自定义处理

```javascript
var book = {
  title: "Professional JavaScript",
  authors: ["Nicholas C. Zakas"],
  edition: 3,
  year: 2011,
  toJSON: function() {
    return this.title;
  }
};
var jsonText = JSON.stringify(book);
```

5. JSON.parse() 解析 JSON 字符串

```javascript
var book = {
  title: "Professional JavaScript",
  authors: ["Nicholas C. Zakas"],
  edition: 3,
  year: 2011,
  releaseDate: new Date(2011, 11, 1)
};
var jsonText = JSON.stringify(book);
var bookCopy = JSON.parse(jsonText, function(key, value) {
  if (key == "releaseDate") {
    return new Date(value);
  } else {
    return value;
  }
});
alert(bookCopy.releaseDate.getFullYear());
```

> IE8 以前不支持 JSON 对象方法可以使用 [json2.js](https://github.com/douglascrockford/JSON-js/blob/master/json2.js)

:::
